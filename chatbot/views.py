from django.shortcuts import render
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.core.cache import cache
from django.contrib.auth.decorators import login_required
from django.core.paginator import Paginator
from django.db.models import Q
import json
import os
import uuid
import time
# from openai import OpenAI
from dotenv import load_dotenv
from .models import ChatHistory, Destination, Hotel, Restaurant, Attraction

# üîë T·∫£i bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env
load_dotenv()

# ‚úÖ Kh·ªüi t·∫°o OpenAI client v·ªõi API Key (commented for now)
# client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Rate limiting configuration
RATE_LIMIT_REQUESTS = 10  # Max requests per minute
RATE_LIMIT_WINDOW = 60   # Window in seconds

def rate_limit_check(request):
    """Simple rate limiting"""
    user_ip = request.META.get('REMOTE_ADDR', 'unknown')
    cache_key = f"rate_limit_{user_ip}"
    
    current_requests = cache.get(cache_key, 0)
    if current_requests >= RATE_LIMIT_REQUESTS:
        return False
    
    cache.set(cache_key, current_requests + 1, RATE_LIMIT_WINDOW)
    return True

def validate_message(message):
    """Validate user input"""
    if not message or not isinstance(message, str):
        return False, "Tin nh·∫Øn kh√¥ng h·ª£p l·ªá"
    
    message = message.strip()
    if len(message) < 1:
        return False, "Tin nh·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng"
    
    if len(message) > 1000:
        return False, "Tin nh·∫Øn qu√° d√†i (t·ªëi ƒëa 1000 k√Ω t·ª±)"
    
    # Basic security check
    forbidden_patterns = ['<script', 'javascript:', 'onload=', 'onerror=']
    message_lower = message.lower()
    for pattern in forbidden_patterns:
        if pattern in message_lower:
            return False, "Tin nh·∫Øn ch·ª©a n·ªôi dung kh√¥ng ƒë∆∞·ª£c ph√©p"
    
    return True, message

def index(request):
    """Trang ch√≠nh c·ªßa chatbot"""
    return render(request, "chatbot/index.html")

def test_view(request):
    """Test view ƒë·ªÉ debug"""
    return HttpResponse("<h1>üéØ TEST VIEW WORKING!</h1>")

def get_travel_context():
    """L·∫•y th√¥ng tin du l·ªãch t·ª´ database ƒë·ªÉ b·ªï sung context cho AI"""
    # Use caching to improve performance
    cache_key = "travel_context"
    context = cache.get(cache_key)
    
    if context is None:
        context_parts = []

        # L·∫•y top destinations v·ªõi optimization
        destinations = Destination.objects.select_related().filter(
            rating__gte=4.0
        ).order_by('-rating')[:10]
        
        if destinations:
            dest_info = "ƒêi·ªÉm ƒë·∫øn ph·ªï bi·∫øn: " + ", ".join(
                [f"{d.name} ({d.city}, {d.country})" for d in destinations]
            )
            context_parts.append(dest_info)

        # L·∫•y top hotels
        hotels = Hotel.objects.select_related('destination').filter(
            rating__gte=4.0
        ).order_by('-rating')[:5]
        
        if hotels:
            hotel_info = "Kh√°ch s·∫°n ƒë·ªÅ xu·∫•t: " + ", ".join(
                [f"{h.name} ({h.destination.city})" for h in hotels]
            )
            context_parts.append(hotel_info)

        context = " | ".join(context_parts)
        # Cache for 1 hour
        cache.set(cache_key, context, 3600)

    return context

@require_http_methods(["POST"])
def chat(request):
    """Chat endpoint v·ªõi b·∫£o m·∫≠t v√† validation t·ªët h∆°n"""
    try:
        # Rate limiting check
        if not rate_limit_check(request):
            return JsonResponse({
                "reply": "Qu√° nhi·ªÅu y√™u c·∫ßu. Vui l√≤ng th·ª≠ l·∫°i sau 1 ph√∫t.",
                "error": "rate_limit_exceeded"
            }, status=429)

        # Parse and validate JSON
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({
                "reply": "D·ªØ li·ªáu kh√¥ng h·ª£p l·ªá.",
                "error": "invalid_json"
            }, status=400)

        user_message = data.get("message", "")

        # Validate message
        is_valid, validated_message = validate_message(user_message)
        if not is_valid:
            return JsonResponse({
                "reply": validated_message,
                "error": "validation_failed"
            }, status=400)

        user_message = validated_message

        # T·∫°o session ID n·∫øu ch∆∞a c√≥
        session_id = request.session.get("chat_session_id")
        if not session_id:
            session_id = str(uuid.uuid4())
            request.session["chat_session_id"] = session_id

        # Record start time for response measurement
        start_time = time.time()

        # L·∫•y context t·ª´ database
        travel_context = get_travel_context()

        # Prompt cho chatbot
        base_prompt = """B·∫°n l√† AI assistant chuy√™n v·ªÅ du l·ªãch Vi·ªát Nam v√† qu·ªëc t·∫ø v·ªõi ki·∫øn th·ª©c s√¢u r·ªông.

NHI·ªÜM V·ª§:
- Cung c·∫•p th√¥ng tin ch√≠nh x√°c, h·ªØu √≠ch v·ªÅ du l·ªãch
- G·ª£i √Ω ƒëi·ªÉm ƒë·∫øn, kh√°ch s·∫°n, nh√† h√†ng, ho·∫°t ƒë·ªông
- T∆∞ v·∫•n l·ªãch tr√¨nh, ph∆∞∆°ng ti·ªán, chi ph√≠
- Chia s·∫ª kinh nghi·ªám th·ª±c t·∫ø

PHONG C√ÅCH:
- Th√¢n thi·ªán, nhi·ªát t√¨nh
- Tr·∫£ l·ªùi chi ti·∫øt nh∆∞ng d·ªÖ hi·ªÉu
- ƒê∆∞a ra g·ª£i √Ω c·ª• th·ªÉ, th·ª±c t·∫ø
- Xu·ªëng d√≤ng ƒë√∫ng c√°ch, ƒë√∫ng ch·ªó

TH√îNG TIN B·ªî SUNG: {travel_context}

C√¢u h·ªèi: {user_message}

H√£y tr·∫£ l·ªùi m·ªôt c√°ch chi ti·∫øt, h·ªØu √≠ch v√† th√¢n thi·ªán:"""

        prompt = base_prompt.format(
            travel_context=travel_context if travel_context else "Ch∆∞a c√≥ d·ªØ li·ªáu c·ª• th·ªÉ",
            user_message=user_message,
        )

        # ‚úÖ G·ªçi GPT-4o v·ªõi timeout v√† error handling (temporarily disabled)
        try:
            # For now, return a simple response
            reply = f"Xin ch√†o! T√¥i ƒë√£ nh·∫≠n ƒë∆∞·ª£c c√¢u h·ªèi: '{user_message}'. Hi·ªán t·∫°i h·ªá th·ªëng AI ƒëang ƒë∆∞·ª£c thi·∫øt l·∫≠p. Vui l√≤ng th·ª≠ l·∫°i sau khi OpenAI API ƒë∆∞·ª£c c·∫•u h√¨nh ƒë·∫ßy ƒë·ªß."
            
            # Original OpenAI code (commented):
            # response = client.chat.completions.create(
            #     model="gpt-4o",
            #     messages=[{"role": "user", "content": prompt}],
            #     max_tokens=800,
            #     temperature=0.7,
            #     timeout=30  # 30 second timeout
            # )
            # reply = response.choices[0].message.content
        except Exception as openai_error:
            print(f"OpenAI API Error: {str(openai_error)}")
            reply = "Xin l·ªói, h·ªá th·ªëng AI t·∫°m th·ªùi kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng th·ª≠ l·∫°i sau."

        # Calculate response time
        response_time = time.time() - start_time

        # L∆∞u v√†o l·ªãch s·ª≠ chat
        try:
            ChatHistory.objects.create(
                session_id=session_id,
                user_message=user_message,
                bot_response=reply,
                response_time=response_time,
                user=request.user if request.user.is_authenticated else None,
            )
        except Exception as db_error:
            print(f"Database error: {str(db_error)}")
            # Continue even if saving fails

        return JsonResponse({
            "reply": reply,
            "response_time": round(response_time, 2)
        })

    except Exception as e:
        error_msg = "Xin l·ªói, c√≥ l·ªói x·∫£y ra v·ªõi h·ªá th·ªëng. Vui l√≤ng th·ª≠ l·∫°i sau."
        print(f"Error in chat view: {str(e)}")

        # V·∫´n l∆∞u l·ªói v√†o l·ªãch s·ª≠ chat ƒë·ªÉ d·ªÖ tra
        try:
            session_id = request.session.get("chat_session_id", str(uuid.uuid4()))
            ChatHistory.objects.create(
                session_id=session_id,
                user_message=user_message if 'user_message' in locals() else "Unknown",
                bot_response=f"ERROR: {str(e)}",
                user=request.user if request.user.is_authenticated else None,
            )
        except:
            pass

        return JsonResponse({
            "reply": error_msg,
            "error": "internal_server_error"
        }, status=500)

def chat_history(request):
    """API ƒë·ªÉ l·∫•y l·ªãch s·ª≠ chat v·ªõi pagination"""
    session_id = request.session.get("chat_session_id")
    if not session_id:
        return JsonResponse({"history": [], "total": 0})

    # Pagination
    page = int(request.GET.get('page', 1))
    per_page = int(request.GET.get('per_page', 20))
    
    history_queryset = ChatHistory.objects.filter(
        session_id=session_id
    ).order_by("timestamp")
    
    paginator = Paginator(history_queryset, per_page)
    history_page = paginator.get_page(page)
    
    history_data = [
        {
            "user_message": chat.user_message,
            "bot_response": chat.bot_response,
            "timestamp": chat.timestamp.strftime("%H:%M"),
            "response_time": chat.response_time,
        }
        for chat in history_page
    ]

    return JsonResponse({
        "history": history_data,
        "total": paginator.count,
        "page": page,
        "has_next": history_page.has_next(),
        "has_previous": history_page.has_previous()
    })

@require_http_methods(["POST"])
def clear_chat(request):
    """Clear chat history for current session"""
    session_id = request.session.get("chat_session_id")
    if session_id:
        ChatHistory.objects.filter(session_id=session_id).delete()
        return JsonResponse({"success": True, "message": "ƒê√£ x√≥a l·ªãch s·ª≠ chat"})
    return JsonResponse({"success": False, "message": "Kh√¥ng c√≥ phi√™n chat"})

def search_destinations(request):
    """Search destinations API"""
    query = request.GET.get('q', '').strip()
    if not query:
        return JsonResponse({"results": []})
    
    destinations = Destination.objects.filter(
        Q(name__icontains=query) |
        Q(city__icontains=query) |
        Q(country__icontains=query) |
        Q(description__icontains=query)
    ).select_related().order_by('-rating')[:10]
    
    results = [
        {
            "id": dest.id,
            "name": dest.name,
            "city": dest.city,
            "country": dest.country,
            "description": dest.description[:200] + "..." if len(dest.description) > 200 else dest.description,
            "rating": dest.rating,
            "average_cost": float(dest.average_cost),
            "best_time": dest.best_time_to_visit
        }
        for dest in destinations
    ]
    
    return JsonResponse({"results": results, "count": len(results)})

def search_hotels(request):
    """Search hotels API"""
    query = request.GET.get('q', '').strip()
    destination_id = request.GET.get('destination_id')
    
    hotels_queryset = Hotel.objects.select_related('destination')
    
    if query:
        hotels_queryset = hotels_queryset.filter(
            Q(name__icontains=query) |
            Q(destination__name__icontains=query) |
            Q(destination__city__icontains=query)
        )
    
    if destination_id:
        hotels_queryset = hotels_queryset.filter(destination_id=destination_id)
    
    hotels = hotels_queryset.order_by('-rating')[:10]
    
    results = [
        {
            "id": hotel.id,
            "name": hotel.name,
            "destination": f"{hotel.destination.city}, {hotel.destination.country}",
            "star_rating": hotel.star_rating,
            "price_per_night": float(hotel.price_per_night),
            "rating": hotel.rating,
            "amenities": hotel.amenities.split(',') if hotel.amenities else []
        }
        for hotel in hotels
    ]
    
    return JsonResponse({"results": results, "count": len(results)})
